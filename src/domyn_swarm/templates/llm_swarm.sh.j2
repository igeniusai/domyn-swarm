#!/bin/bash
###############################################################################
#  SLURM DIRECTIVES
###############################################################################
#SBATCH --account={{ cfg.backend.account }}
{% if cfg.mail_user %}
#SBATCH --mail-type=END,FAIL
#SBATCH --mail-user={{ cfg.backend.mail_user }}
{% endif %}
#SBATCH --qos=qos_llm_min
#SBATCH --exclusive=user
#SBATCH --job-name={{ job_name }}
#SBATCH --partition={{ cfg.backend.partition }}
#SBATCH --ntasks-per-node=1
#SBATCH --gres=gpu:{{ cfg.gpus_per_node }}
#SBATCH --cpus-per-task={{ cfg.cpus_per_task }}
#SBATCH --mem=0
#SBATCH --time={{ cfg.backend.time_limit }}
{% if cfg.backend.exclude_nodes %}
#SBATCH --exclude={{ cfg.backend.exclude_nodes }}
{% endif %}
{% if cfg.backend.node_list %}
#SBATCH --nodelist={{ cfg.backend.node_list | default('') }}
{% endif %}
#SBATCH --output={{ swarm_directory }}/logs/slurm/{{ job_name }}.%j.out
#SBATCH --error={{ swarm_directory }}/logs/slurm/{{ job_name }}.%j.err

set -euo pipefail

module purge
module load cuda/12.6

###############################################################################
#  ENVIRONMENT VARIABLES
###############################################################################
export VLLM_IMAGE="{{ cfg.image }}"
export HF_HOME="{{ cfg.env.HF_HOME }}"

# User-defined environment variables (to be passed to Singularity)
{% for k, v in (cfg.env | default({}, true)).items() -%}
{% set KEY = k|upper|replace('-', '_') %}
export SINGULARITYENV_{{ KEY }}="{{ v | string | replace('\\','\\\\') | replace('"','\\"') }}"
{% endfor -%}

export REPLICAS={{ cfg.replicas }}
export GPUS_PER_REPLICA={{ cfg.gpus_per_replica }}
{% if not cfg.backend.requires_ray %}
export REPLICAS_PER_NODE={{ cfg.replicas_per_node }}
{% endif %}
export HF_HUB_OFFLINE=1
export PYTHONNOUSERSITE=1
export RAY_CGRAPH_get_timeout=1200


# Calculated variables
export GPUS_PER_NODE={{ cfg.gpus_per_node }}
export TOTAL_GPUS=$(( SLURM_JOB_NUM_NODES * {{ cfg.gpus_per_node }} ))
export REQUIRED_GPUS=$(( REPLICAS * GPUS_PER_REPLICA ))

# Job-specific variables
REPL_ID=${SLURM_ARRAY_TASK_ID:-0}
REPL_JOB_ID=${SLURM_ARRAY_JOB_ID:-$SLURM_JOB_ID}
{% if not cfg.backend.requires_ray %}
GLOBAL_BASE=$(( REPL_ID * REPLICAS_PER_NODE ))
{% endif %}
export SWARM_DIR="{{ swarm_directory }}"
export LOG_DIR={{ swarm_directory }}/logs/replicas/replica-${REPL_ID}
export VLLM_HOST_IP=$(hostname -I | awk '{print $1}')
mkdir -p "$LOG_DIR"

###############################################################################
#  NODE AND PORT CONFIGURATION
###############################################################################
mapfile -t NODES < <(scontrol show hostnames "$SLURM_JOB_NODELIST")
HEAD_NODE=${NODES[0]}
INSTANCE_TAG="{{ job_name }}_${REPL_ID}_head"
HEAD_PORT="{{ cfg.backend.ray_port }}"
REST_PORT="{{ cfg.port }}"

echo "ðŸŸ¢ Allocation: $SLURM_JOB_NUM_NODES nodes â†’ head=$HEAD_NODE workers=${NODES[*]:1}"

# Mount configuration
export MOUNTS="$HF_HOME,/sys,/dev/infiniband,/leonardo/prod/opt/,$HOME,$SWARM_DIR"
{% if is_folder(cfg.model) and path_exists(cfg.model) %}
MOUNTS=$MOUNTS,{{ cfg.model }}
{% endif %}

###############################################################################
#  SINGLE-NODE or SHARED-NODES DEPLOYMENT
###############################################################################
{% if not cfg.backend.requires_ray %}
echo "[single-node] Running colocated replicas..."

function start_vllm_replica() {
  local global_id=$1
  local port=$2
  local node=$3
  local log_dir="$LOG_DIR/replica-$global_id"

  # Map each replica to a distinct contiguous GPU set on the node:
  # replica index on the node (0..(GPUS_PER_NODE/GPUS_PER_REPLICA - 1))
  local r_on_node=$(( global_id % (GPUS_PER_NODE / GPUS_PER_REPLICA) ))
  local first_gpu=$(( r_on_node * GPUS_PER_REPLICA ))
  local last_gpu=$(( first_gpu + GPUS_PER_REPLICA - 1 ))

  local gpu_map="$(seq -s, $first_gpu $last_gpu)"

  echo "[replica $global_id] using GPUs $gpu_map on $node"

  mkdir -p "$log_dir"
  echo "[replica $global_id] â†’ $node port=$port"

  echo "VLLM logging will be written to $log_dir/vllm.log"
  srun --export=ALL -n1 -N1 -w $node --gres=gpu:{{ cfg.gpus_per_replica }} --overlap --gpu-bind=map_gpu:"${gpu_map}" \
     --cpus-per-task={{ cfg.cpus_per_task }} \
     singularity exec --bind $MOUNTS --nv --writable-tmpfs "$VLLM_IMAGE" \
     vllm serve {{ cfg.model }} \
     {% if 'tensor-parallel-size' not in cfg.args %}
     --tensor-parallel-size {{ [cfg.gpus_per_replica,cfg.gpus_per_node] | min  }} \
     {% endif %}
     {{ cfg.args }} \
     --port $port \
     >> "$log_dir/vllm.log" 2>&1 &
}

function wait_for_vllm_ready() {
  local endpoint=$1
  local replica_id=$2

  echo "[head] waiting for $endpoint ..."
  while :; do
    resp=$(curl -sf -w '\n%{http_code}' "http://$endpoint/v1/models" || true)
    body=${resp%$'\n'*}
    code=${resp##*$'\n'}

    if [[ $code == 200 ]]; then
      echo "[head] $endpoint is READY âœ…"
      local head_file="{{ swarm_directory }}/serving/replica-${replica_id}.head"
      echo "$endpoint" > "$head_file"
      break
    fi

    echo "[head] $endpoint not ready (code=$code), retrying..."
    sleep 5
  done
}


# Start all replicas
declare -a global_ids=()
declare -a ports=()
declare -a hosts=()

for ((i=0; i<REPLICAS_PER_NODE; i++)); do
  GLOBAL_ID=$(( GLOBAL_BASE + i ))
  # If the length of NODES is 1, we are on a single node allocation
  # so we always use the first node
  {% raw %}
  if (( ${#NODES[@]} == 1 )); then
  {% endraw %}
    idx=0
  else
    idx=$(( GLOBAL_ID / REPLICAS_PER_NODE ))
  fi
  VLLM_PORT=$(( {{ cfg.port }} + GLOBAL_ID ))

  global_ids+=("$GLOBAL_ID")
  ports+=("$VLLM_PORT")
  {% raw %}
  if [[ -z ${NODES[idx]+_} ]]; then
    echo "ERROR: NODES[$idx] is unset. NODES has ${#NODES[@]} items. \
  GLOBAL_ID=$GLOBAL_ID REPLICAS_PER_NODE=$REPLICAS_PER_NODE \
  SLURM_JOB_NODELIST=${SLURM_JOB_NODELIST:-<unset>}, NODES=$NODES" >&2
    exit 1
  fi
  {% endraw %}
  hosts+=( "${NODES[idx]}" )

  start_vllm_replica "$GLOBAL_ID" "$VLLM_PORT" "${hosts[-1]}"
done

# Wait for all replicas to be ready
{% raw %}
echo "[head] checking vLLM readiness for ${#global_ids[@]} replicas..."
for ((j = 0; j < ${#global_ids[@]}; j++)); do
{% endraw %}
  id=${global_ids[$j]}
  port=${ports[$j]}
  host=${hosts[$j]}
  endpoint="$host:$port"

  wait_for_vllm_ready "$endpoint" "$id"
done

trap 'echo "[batch] caught SIGTERM â†’ shutting down"; exit 0' SIGTERM

# Keep job alive
while true; do
  sleep 60
done

{% else %}
###############################################################################
#  MULTI-NODE DEPLOYMENT (RAY)
###############################################################################
echo "[multi-node] Running $REPLICAS replicas on $SLURM_JOB_NUM_NODES nodes with $GPUS_PER_REPLICA GPU(s) each..."

# NCCL configuration for multi-node communication
export NCCL_DEBUG=WARN
# export NCCL_OOB_NET_ENABLE=1
# export NCCL_OOB_NET_IFNAME="mlx5"
export NCCL_SOCKET_IFNAME=ib
export NCCL_IB_HCA="mlx5"
export NCCL_ASYNC_ERROR_HANDLING=1
export TORCH_CUDA_ALLOC_CONF=garbage_collection_threshold:0.6,max_split_size_mb:512
export NCCL_IB_SL=1
export NCCL_IB_CUDA_SUPPORT=1
export NCCL_IB_GDR_LEVEL=SYS
export NCCL_P2P_LEVEL=NVL
export NCCL_CUMEM_ENABLE=1
RAY_LOG_DIR="$LOG_DIR/ray"

function start_ray_head() {
  echo "[head] starting Singularity instance ($HEAD_NODE)..."
  REPLICA_ENV={{ swarm_directory }}/serving/replica-${REPL_ID}.env
  echo "VLLM_HOST_IP=$VLLM_HOST_IP" > $REPLICA_ENV

  singularity instance start --bind $MOUNTS --contain --writable-tmpfs \
                --env-file $REPLICA_ENV \
                --nv "$VLLM_IMAGE" "$INSTANCE_TAG" \
                --disable-usage-stats --head --block \
                --port=$HEAD_PORT --dashboard-host=0.0.0.0 --dashboard-port={{ cfg.backend.ray_dashboard_port }} --include-dashboard=true
  echo "[head] Singularity instance started: instance://$INSTANCE_TAG"

  ln -s "$HOME/.singularity/instances/$(hostname -f)/logs/$INSTANCE_TAG/$USER/" $RAY_LOG_DIR/head
}

function wait_for_ray_ready() {
  echo "[head] waiting for Ray to come up ..."
  until singularity exec instance://"$INSTANCE_TAG" ray status &>/dev/null; do
    singularity exec instance://"$INSTANCE_TAG" env | grep VLLM_HOST_IP
    sleep 2
  done
  echo "[head] Ray OK"
}

function start_ray_workers() {
  local comma_separated_workers=$(IFS=,; echo "${NODES[*]:1}")
  echo "[workers] launching Ray workers on $((SLURM_JOB_NUM_NODES-1)) nodes ($comma_separated_workers)..."

  srun --ntasks=$((SLURM_JOB_NUM_NODES-1)) \
     --nodelist=$comma_separated_workers \
     --nodes=$((SLURM_JOB_NUM_NODES-1)) \
     --ntasks-per-node=1 \
     --exclusive \
     --error="$RAY_LOG_DIR/workers/worker_%N_%t.err" \
     --output="$RAY_LOG_DIR/workers/worker_%N_%t.out" \
     bash -c '
       export SINGULARITYENV_VLLM_HOST_IP=$(hostname -I | awk "{print \$1}")
       echo "VLLM_HOST_IP is $SINGULARITYENV_VLLM_HOST_IP"
       singularity exec --bind '"$MOUNTS"' --nv --contain --writable-tmpfs \
         '"$VLLM_IMAGE"' \
         ray start --disable-usage-stats \
               --address='"$HEAD_NODE"':'"$HEAD_PORT"' \
               --block
     ' &

  echo "[workers] waiting for workers to start ..."
  sleep 60
}

function start_vllm_server() {
  echo "[head] starting vLLM REST server ..."
  singularity exec --bind $MOUNTS --nv --contain --writable-tmpfs --env VLLM_USE_PRECOMPILED=1 \
           instance://"$INSTANCE_TAG" \
           vllm serve {{ cfg.model }} \
           {% if 'tensor-parallel-size' not in cfg.args %}
           --tensor-parallel-size {{ [cfg.gpus_per_replica,cfg.gpus_per_node] | min }} \
           {% endif %}
           --distributed-executor-backend ray \
           {{ cfg.args | default('') }} \
           --port $REST_PORT \
           >> "$RAY_LOG_DIR/vllm.log" 2>&1 &
}

function wait_for_vllm_server_ready() {
  echo "[head] checking vLLM status ..."
  while :; do
    resp=$(curl -sf -w '\n%{http_code}' "http://$HEAD_NODE:$REST_PORT/v1/models" || true)
    body=${resp%$'\n'*}
    code=${resp##*$'\n'}

    if [[ $code == 200 ]]; then
      echo "[head] vLLM is READY (HTTP 200)"
      break
    fi

    echo "[head] waiting for vLLM (code=$code)â€¦"
    sleep 5
  done

  echo "[head] REST ready â†’ http://$HEAD_NODE:$REST_PORT"
  local head_file="{{ swarm_directory }}/serving/replica-${REPL_ID}.head"
  echo "$HEAD_NODE:$REST_PORT" > "$head_file"
}

# Execute multi-node deployment steps
mkdir -p "$RAY_LOG_DIR/workers"
start_ray_head
wait_for_ray_ready
start_ray_workers
echo "[head] checking Ray status ..."
singularity exec instance://"$INSTANCE_TAG" ray status
start_vllm_server
wait_for_vllm_server_ready

# Keep job alive
trap 'echo "[batch] caught SIGTERM â†’ shutting down"; exit 0' SIGTERM

while true; do
  sleep 60
done

singularity instance stop "$INSTANCE_TAG" || true
{% endif %}
