#!/bin/bash
###############################################################################
#  SLURM DIRECTIVES
###############################################################################
#SBATCH --account={{ cfg.backend.account }}
{% if cfg.mail_user %}
#SBATCH --mail-type=END,FAIL
#SBATCH --mail-user={{ cfg.backend.mail_user }}
{% endif %}
#SBATCH --qos={{ cfg.backend.qos }}
#SBATCH --exclusive=user
#SBATCH --job-name={{ job_name }}
#SBATCH --partition={{ cfg.backend.partition }}
#SBATCH --ntasks-per-node=1
#SBATCH --gres=gpu:{{ cfg.gpus_per_node }}
#SBATCH --cpus-per-task={{ cfg.cpus_per_task }}
#SBATCH --mem=0
#SBATCH --time={{ cfg.backend.time_limit }}
{% if cfg.backend.exclude_nodes %}
#SBATCH --exclude={{ cfg.backend.exclude_nodes }}
{% endif %}
{% if cfg.backend.node_list %}
#SBATCH --nodelist={{ cfg.backend.node_list | default('') }}
{% endif %}
#SBATCH --output={{ swarm_directory }}/logs/slurm/{{ job_name }}.%j.out
#SBATCH --error={{ swarm_directory }}/logs/slurm/{{ job_name }}.%j.err
{% for pre in cfg.backend.preamble %}
#SBATCH {{ pre }}
{% endfor %}

set -euo pipefail

module purge
{% for mod in cfg.backend.modules %}
module load {{ mod }}
{% endfor %}

###############################################################################
#  ENVIRONMENT VARIABLES
###############################################################################
export VLLM_IMAGE="{{ cfg.image }}"
export HF_HOME="{{ cfg.env.HF_HOME }}"

# User-defined environment variables (to be passed to Singularity)
{% for k, v in (cfg.env | default({}, true)).items() -%}
{% set KEY = k|replace('-', '_') %}
export SINGULARITYENV_{{ KEY }}="{{ v | string | replace('\\','\\\\') | replace('"','\\"') }}"
export {{ KEY }}="{{ v | string | replace('\\','\\\\') | replace('"','\\"') }}"
{% endfor -%}

export REPLICAS={{ cfg.replicas }}
export GPUS_PER_REPLICA={{ cfg.gpus_per_replica }}
{% if not cfg.backend.requires_ray %}
export REPLICAS_PER_NODE={{ cfg.replicas_per_node }}
{% endif %}
export HF_HUB_OFFLINE=1
export PYTHONNOUSERSITE=1


# Calculated variables
export GPUS_PER_NODE={{ cfg.gpus_per_node }}
export TOTAL_GPUS=$(( SLURM_JOB_NUM_NODES * {{ cfg.gpus_per_node }} ))
export REQUIRED_GPUS=$(( REPLICAS * GPUS_PER_REPLICA ))

# Job-specific variables
REPL_ID=${SLURM_ARRAY_TASK_ID:-0}
REPL_JOB_ID=${SLURM_ARRAY_JOB_ID:-$SLURM_JOB_ID}
{% if not cfg.backend.requires_ray %}
GLOBAL_BASE=$(( REPL_ID * REPLICAS_PER_NODE ))
{% endif %}
export SWARM_DIR="{{ swarm_directory }}"
export LOG_DIR={{ swarm_directory }}/logs/replicas/replica-${REPL_ID}
export VLLM_HOST_IP=$(hostname -I | awk '{print $1}')
export VLLM_API_KEY="${SINGULARITYENV_VLLM_API_KEY:-${VLLM_API_KEY:-${API_TOKEN:-}}}"
mkdir -p "$LOG_DIR"

###############################################################################
#  NODE AND PORT CONFIGURATION
###############################################################################
mapfile -t NODES < <(scontrol show hostnames "$SLURM_JOB_NODELIST")
HEAD_NODE=${NODES[0]}
INSTANCE_TAG="{{ job_name }}_${REPL_ID}_head"
HEAD_PORT="{{ cfg.backend.ray_port }}"
REST_PORT="{{ cfg.port }}"

echo "ðŸŸ¢ Allocation: $SLURM_JOB_NUM_NODES nodes â†’ head=$HEAD_NODE workers=${NODES[*]:1}"

# Mount configuration
export MOUNTS="$HF_HOME,/sys,/dev/infiniband,/leonardo/prod/opt/,$HOME,$SWARM_DIR,{{ watchdog_script_path }}:/opt/watchdog.py"
{% if is_folder(cfg.model) and path_exists(cfg.model) %}
MOUNTS=$MOUNTS,{{ cfg.model }}
{% endif %}

#Wait for creation of file "SWARM_DIR/serving/collector.env" containing COLLECTOR_HOST and COLLECTOR_PORT
echo "[replica $REPL_ID] waiting for collector.env file..."
while [ ! -f "{{ swarm_directory }}/serving/collector.env" ]; do
    sleep 2
done

source "{{ swarm_directory }}/serving/collector.env"
echo "[replica $REPL_ID] loaded collector config: COLLECTOR_HOST=$COLLECTOR_HOST COLLECTOR_PORT=$COLLECTOR_PORT"

###############################################################################
#  SINGLE-NODE or SHARED-NODES DEPLOYMENT
###############################################################################
{% if not cfg.backend.requires_ray %}
echo "[single-node] Running colocated replicas..."

function start_vllm_replica() {
  local global_id=$1
  local port=$2
  local node=$3
  local log_dir="$LOG_DIR/replica-$global_id"

  # Map each replica to a distinct contiguous GPU set on the node:
  # replica index on the node (0..(GPUS_PER_NODE/GPUS_PER_REPLICA - 1))
  local r_on_node=$(( global_id % (GPUS_PER_NODE / GPUS_PER_REPLICA) ))
  local first_gpu=$(( r_on_node * GPUS_PER_REPLICA ))
  local last_gpu=$(( first_gpu + GPUS_PER_REPLICA - 1 ))

  local gpu_map="$(seq -s, $first_gpu $last_gpu)"

  echo "[replica $global_id] using GPUs $gpu_map on $node"

  mkdir -p "$log_dir"
  echo "[replica $global_id] â†’ $node port=$port"

  echo "VLLM logging will be written to $log_dir/vllm.log"
  srun --export=ALL -n1 -N1 -w $node --gres=gpu:{{ cfg.gpus_per_replica }} \
     --cpus-per-task={{ cfg.cpus_per_task }} \
     singularity exec --bind $MOUNTS --nv --writable-tmpfs "$VLLM_IMAGE" \
     python3 /opt/watchdog.py \
      --swarm-id {{ job_name }} \
      --replica-id $global_id \
      --node $node \
      --port $port \
      --db "$SWARM_DIR/watchdog.db" \
      --probe-interval {{ cfg.watchdog.probe_interval }} \
      --http-path "{{ cfg.watchdog.http_path }}" \
      --http-timeout {{ cfg.watchdog.http_timeout }} \
      --restart-policy {{ cfg.watchdog.restart_policy }} \
      --readiness-timeout {{ cfg.watchdog.readiness_timeout }} \
      --unhealthy-restart-after {{ cfg.watchdog.unhealthy_restart_after }} \
      --max-restarts {{ cfg.watchdog.max_restarts }} \
      --log-dir "$log_dir" \
      --collector-address "$COLLECTOR_HOST:$COLLECTOR_PORT" \
      -- \
     vllm serve {{ cfg.model }} \
     {% if 'tensor-parallel-size' not in cfg.args %}
     --tensor-parallel-size {{ [cfg.gpus_per_replica,cfg.gpus_per_node] | min  }} \
     {% endif %}
     {{ cfg.args }} \
     --port $port \
     >> "$log_dir/vllm.log" 2>&1 &
}

function wait_for_vllm_ready() {
  local endpoint=$1
  local replica_id=$2

  echo "[head] waiting for $endpoint ..."
  while :; do

    if [[ -n $VLLM_API_KEY ]]; then
      resp=$(curl -sf -H "Authorization: Bearer $VLLM_API_KEY" -w '\n%{http_code}' "http://$endpoint/health" || true)
    else
      resp=$(curl -sf -w '\n%{http_code}' "http://$endpoint/health" || true)
    fi
    body=${resp%$'\n'*}
    code=${resp##*$'\n'}

    if [[ $code == 200 ]]; then
      echo "[head] $endpoint is READY âœ…"
      local head_file="{{ swarm_directory }}/serving/replica-${replica_id}.head"
      echo "$endpoint" > "$head_file"
      break
    fi

    echo "[head] $endpoint not ready (code=$code), retrying..."
    sleep 5
  done
}


# Start all replicas
declare -a global_ids=()
declare -a ports=()
declare -a hosts=()

for ((i=0; i<REPLICAS_PER_NODE; i++)); do
  GLOBAL_ID=$(( GLOBAL_BASE + i ))
  # If the length of NODES is 1, we are on a single node allocation
  # so we always use the first node
  {% raw %}
  if (( ${#NODES[@]} == 1 )); then
  {% endraw %}
    idx=0
  else
    idx=$(( GLOBAL_ID / REPLICAS_PER_NODE ))
  fi
  VLLM_PORT=$(( {{ cfg.port }} + GLOBAL_ID ))

  global_ids+=("$GLOBAL_ID")
  ports+=("$VLLM_PORT")
  {% raw %}
  if [[ -z ${NODES[idx]+_} ]]; then
    echo "ERROR: NODES[$idx] is unset. NODES has ${#NODES[@]} items. \
  GLOBAL_ID=$GLOBAL_ID REPLICAS_PER_NODE=$REPLICAS_PER_NODE \
  SLURM_JOB_NODELIST=${SLURM_JOB_NODELIST:-<unset>}, NODES=$NODES" >&2
    exit 1
  fi
  {% endraw %}
  hosts+=( "${NODES[idx]}" )

  start_vllm_replica "$GLOBAL_ID" "$VLLM_PORT" "${hosts[-1]}"
done

# Wait for all replicas to be ready
{% raw %}
echo "[head] checking vLLM readiness for ${#global_ids[@]} replicas..."
for ((j = 0; j < ${#global_ids[@]}; j++)); do
{% endraw %}
  id=${global_ids[$j]}
  port=${ports[$j]}
  host=${hosts[$j]}
  endpoint="$host:$port"

  wait_for_vllm_ready "$endpoint" "$id"
done

trap 'echo "[batch] caught SIGTERM â†’ shutting down"; exit 0' SIGTERM

# Keep job alive
while true; do
  sleep 60
done

{% else %}
###############################################################################
#  MULTI-NODE DEPLOYMENT (RAY)
###############################################################################
echo "[multi-node] Running $REPLICAS replicas on $SLURM_JOB_NUM_NODES nodes with $GPUS_PER_REPLICA GPU(s) each..."

# NCCL configuration for multi-node communication
RAY_LOG_DIR="$LOG_DIR/ray"

function start_ray_head() {
  echo "[head] starting Singularity instance ($HEAD_NODE)..."
  REPLICA_ENV={{ swarm_directory }}/serving/replica-${REPL_ID}.env
  echo "VLLM_HOST_IP=$VLLM_HOST_IP" > $REPLICA_ENV
  mkdir -p $TMPDIR/ray_tmp

  singularity instance start --bind $MOUNTS,$TMPDIR/ray_tmp:/tmp --contain --writable-tmpfs \
                --env-file $REPLICA_ENV \
                --nv "$VLLM_IMAGE" "$INSTANCE_TAG" \
                --disable-usage-stats --head --block \
                --port=$HEAD_PORT --dashboard-host=0.0.0.0 --dashboard-port={{ cfg.backend.ray_dashboard_port }} --include-dashboard=true
  echo "[head] Singularity instance started: instance://$INSTANCE_TAG"

  src="$HOME/.singularity/instances/logs/$(hostname -f)/$USER"
  dst="$RAY_LOG_DIR/head"
  mkdir -p "$dst"

  find "$src" -maxdepth 1 -type f -name "${INSTANCE_TAG}*" -print0 |
    while IFS= read -r -d '' f; do
      ln -sfn "$f" "$dst/$(basename "$f")"
    done
}

function wait_for_ray_ready() {
  echo "[head] waiting for Ray to come up ..."
  until singularity exec instance://"$INSTANCE_TAG" ray status &>/dev/null; do
    singularity exec instance://"$INSTANCE_TAG" env | grep VLLM_HOST_IP
    sleep 2
  done
  echo "[head] Ray OK"
}

function start_ray_workers() {
  local comma_separated_workers=$(IFS=,; echo "${NODES[*]:1}")
  echo "[workers] launching Ray workers on $((SLURM_JOB_NUM_NODES-1)) nodes ($comma_separated_workers)..."

  srun --ntasks=$((SLURM_JOB_NUM_NODES-1)) \
     --nodelist=$comma_separated_workers \
     --nodes=$((SLURM_JOB_NUM_NODES-1)) \
     --ntasks-per-node=1 \
     --exclusive \
     --error="$RAY_LOG_DIR/workers/worker_%N_%t.err" \
     --output="$RAY_LOG_DIR/workers/worker_%N_%t.out" \
     bash -c '
       export SINGULARITYENV_VLLM_HOST_IP=$(hostname -I | awk "{print \$1}")
       echo "VLLM_HOST_IP is $SINGULARITYENV_VLLM_HOST_IP"
       singularity exec --bind '"$MOUNTS"' --nv --contain --writable-tmpfs \
         '"$VLLM_IMAGE"' \
         ray start --disable-usage-stats \
               --address='"$HEAD_NODE"':'"$HEAD_PORT"' \
               --block
     ' &

  echo "[workers] waiting for workers to start ..."
  sleep 60
}

function start_vllm_server() {
  echo "[head] starting vLLM REST server ..."
  singularity exec --bind $MOUNTS --nv --contain --writable-tmpfs --env VLLM_USE_PRECOMPILED=1 \
           instance://"$INSTANCE_TAG" \
           python3 /opt/watchdog.py \
            --swarm-id {{job_name}} \
            --replica-id=0 \
            --node $HEAD_NODE \
            --port $HEAD_PORT \
            --db "$SWARM_DIR/watchdog.db" \
            --probe-interval {{ cfg.watchdog.probe_interval }} \
            --http-path "{{ cfg.watchdog.http_path }}" \
            --http-timeout {{ cfg.watchdog.http_timeout }} \
            --restart-policy {{ cfg.watchdog.restart_policy }} \
            --readiness-timeout {{ cfg.watchdog.readiness_timeout }} \
            --unhealthy-restart-after {{ cfg.watchdog.unhealthy_restart_after }} \
            --max-restarts {{ cfg.watchdog.max_restarts }} \
            --ray-enabled 1 \
            --ray-expected-tp {{ [cfg.gpus_per_replica,cfg.gpus_per_node] | min }} \
            --ray-exec-prefix singularity exec instance://"$INSTANCE_TAG" \
            --log-dir "$RAY_LOG_DIR" \
            -- \
           vllm serve {{ cfg.model }} \
           {% if 'tensor-parallel-size' not in cfg.args %}
           --tensor-parallel-size {{ [cfg.gpus_per_replica,cfg.gpus_per_node] | min }} \
           {% endif %}
           --distributed-executor-backend ray \
           {{ cfg.args | default('') }} \
           --port $REST_PORT \
           >> "$RAY_LOG_DIR/vllm.log" 2>&1 &
}

function wait_for_vllm_server_ready() {
  echo "[head] checking vLLM status ..."
  local endpoint="$HEAD_NODE:$REST_PORT"
  while :; do

    if [[ -n $VLLM_API_KEY ]]; then
      resp=$(curl -sf -H "Authorization: Bearer $VLLM_API_KEY" -w '\n%{http_code}' "http://$endpoint/health" || true)
    else
      resp=$(curl -sf -w '\n%{http_code}' "http://$endpoint/health" || true)
    fi

    body=${resp%$'\n'*}
    code=${resp##*$'\n'}

    if [[ $code == 200 ]]; then
      echo "[head] vLLM is READY (HTTP 200)"
      break
    fi

    echo "[head] waiting for vLLM (code=$code)â€¦"
    sleep 5
  done

  echo "[head] REST ready â†’ http://$HEAD_NODE:$REST_PORT"
  local head_file="{{ swarm_directory }}/serving/replica-${REPL_ID}.head"
  echo "$HEAD_NODE:$REST_PORT" > "$head_file"
}

# Execute multi-node deployment steps
mkdir -p "$RAY_LOG_DIR/workers"
start_ray_head
wait_for_ray_ready
start_ray_workers
echo "[head] checking Ray status ..."
singularity exec instance://"$INSTANCE_TAG" ray status
start_vllm_server
wait_for_vllm_server_ready

# Keep job alive
trap 'echo "[batch] caught SIGTERM â†’ shutting down"; exit 0' SIGTERM

while true; do
  sleep 60
done

singularity instance stop "$INSTANCE_TAG" || true
{% endif %}
