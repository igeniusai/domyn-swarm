#!/bin/bash
###############################################################################
#  SLURM DIRECTIVES
###############################################################################
#SBATCH --account=iGen_train
{% if cfg.mail_user %}
#SBATCH --mail-type=END,FAIL
#SBATCH --mail-user={{ cfg.mail_user }}
{% endif %}
#SBATCH --qos=qos_llm_min
#SBATCH --exclusive=user
#SBATCH --job-name={{ job_name }}
#SBATCH --partition={{ cfg.partition }}      
#SBATCH --nodes={{ cfg.nodes }}              
#SBATCH --ntasks-per-node=1
#SBATCH --gres=gpu:{{ cfg.gpus_per_node }}
#SBATCH --cpus-per-task={{ cfg.cpus_per_task }}
#SBATCH --mem=0
#SBATCH --time={{ cfg.time_limit }}
{% if cfg.exclude_nodes %}
#SBATCH --exclude={{ cfg.exclude_nodes }}
{% endif %}
{% if cfg.node_list %}
#SBATCH --nodelist={{ cfg.node_list | default('') }}
{% endif %}
#SBATCH --output={{ cfg.log_directory }}/{{ job_name }}/%x.%j.out
#SBATCH --error={{ cfg.log_directory }}/{{ job_name }}/%x.%j.err

set -euo pipefail

module purge
module load cuda/12.2

###############################################################################
#  ENVIRONMENT VARIABLES
###############################################################################
export VLLM_IMAGE="{{ cfg.vllm_image }}"
export HF_HOME="{{ cfg.hf_home }}"
export REPLICAS={{ cfg.replicas }}
export GPUS_PER_REPLICA={{ cfg.gpus_per_replica }}
{% if not cfg.requires_ray %}
export REPLICAS_PER_NODE={{ cfg.replicas_per_node }}
{% endif %}
export HF_HUB_OFFLINE=1
export PYTHONNOUSERSITE=1
export RAY_CGRAPH_get_timeout=1200
export VLLM_USE_V1=0

# Calculated variables
export TOTAL_GPUS=$(( SLURM_JOB_NUM_NODES * {{ cfg.gpus_per_node }} ))
export REQUIRED_GPUS=$(( REPLICAS * GPUS_PER_REPLICA ))

# Job-specific variables
REPL_ID=${SLURM_ARRAY_TASK_ID:-0}
REPL_JOB_ID=${SLURM_ARRAY_JOB_ID:-$SLURM_JOB_ID}
{% if not cfg.requires_ray %}
GLOBAL_BASE=$(( REPL_ID * REPLICAS_PER_NODE ))
{% endif %}
export LOG_DIR={{ cfg.log_directory }}/${REPL_JOB_ID}/${REPL_ID}
export VLLM_HOST_IP=$(hostname -I | awk '{print $1}')
mkdir -p "$LOG_DIR"

###############################################################################
#  NODE AND PORT CONFIGURATION
###############################################################################
NODES=($(scontrol show hostnames "$SLURM_JOB_NODELIST"))
HEAD_NODE=${NODES[0]}
INSTANCE_TAG="{{ job_name }}_${REPL_ID}_head"
HEAD_PORT="{{ cfg.ray_port }}"
REST_PORT="{{ cfg.vllm_port }}"

echo "ðŸŸ¢ Allocation: $SLURM_JOB_NUM_NODES nodes â†’ head=$HEAD_NODE workers=${NODES[*]:1}"

# Mount configuration
export MOUNTS="$HF_HOME:$HF_HOME,/sys,/dev/infiniband,/etc/libibverbs.d,/leonardo/prod/spack/5.2"
{% if is_folder(cfg.model) and path_exists(cfg.model) %}
MOUNTS=$MOUNTS,{{ cfg.model }}
{% endif %}

###############################################################################
#  SINGLE-NODE or SHARED-NODES DEPLOYMENT
###############################################################################
{% if not cfg.requires_ray %}
echo "[single-node] Running colocated replicas..."

function start_vllm_replica() {
  local global_id=$1
  local port=$2
  local node=$3
  local log_dir="$LOG_DIR/replica_$global_id"
  
  mkdir -p "$log_dir"
  echo "[replica $global_id] â†’ $node port=$port"
  
  srun -n1 -N1 --gres=gpu:{{ cfg.gpus_per_replica }} {% if cfg.replicas_per_node > cfg.gpus_per_node %}--overlap{% endif %} \
     --cpus-per-task={{ cfg.cpus_per_task }} \
     singularity exec --bind $MOUNTS --nv --contain "$VLLM_IMAGE" \
     vllm serve {{ cfg.model }} \
     {% if 'tensor-parallel-size' not in cfg.vllm_args %}
     --tensor-parallel-size {{ [cfg.gpus_per_replica,cfg.gpus_per_node] | min  }} \
     {% endif %}
     {{ cfg.vllm_args }} \
     --port $port \
     >> "$log_dir/vllm.log" 2>&1 &
}

function wait_for_vllm_ready() {
  local endpoint=$1
  local replica_id=$2
  
  echo "[head] waiting for $endpoint ..."
  while :; do
    resp=$(curl -sf -w '\n%{http_code}' "http://$endpoint/v1/models" || true)
    body=${resp%$'\n'*}
    code=${resp##*$'\n'}
    
    if [[ $code == 200 ]]; then
      echo "[head] $endpoint is READY âœ…"
      local head_file="{{ cfg.home_directory }}/swarms/${REPL_JOB_ID}/${replica_id}.head"
      echo "$endpoint" > "$head_file"
      break
    fi
    
    echo "[head] $endpoint not ready (code=$code), retrying..."
    sleep 5
  done
}

# Start all replicas
declare -a global_ids=()
declare -a ports=()
declare -a hosts=()

for ((i=0; i<REPLICAS_PER_NODE; i++)); do
  GLOBAL_ID=$(( GLOBAL_BASE + i ))
  VLLM_PORT=$(( {{ cfg.vllm_port }} + GLOBAL_ID ))
  
  global_ids+=("$GLOBAL_ID")
  ports+=("$VLLM_PORT")
  hosts+=("$HEAD_NODE")
  
  start_vllm_replica "$GLOBAL_ID" "$VLLM_PORT" "$HEAD_NODE"
done

# Wait for all replicas to be ready
{% raw %}
echo "[head] checking vLLM readiness for ${#global_ids[@]} replicas..."
for ((j = 0; j < ${#global_ids[@]}; j++)); do
{% endraw %}
  id=${global_ids[$j]}
  port=${ports[$j]}
  host=${hosts[$j]}
  endpoint="$host:$port"
  
  wait_for_vllm_ready "$endpoint" "$id"
done

trap 'echo "[batch] caught SIGTERM â†’ shutting down"; exit 0' SIGTERM

# Keep job alive
while true; do
  sleep 60
done

###############################################################################
#  MULTI-NODE DEPLOYMENT (RAY)
###############################################################################
{% else %}
echo "[multi-node] Running $REPLICAS replicas on $SLURM_JOB_NUM_NODES nodes with $GPUS_PER_REPLICA GPU(s) each..."

# NCCL configuration for multi-node communication
export NCCL_DEBUG=WARN
# export NCCL_OOB_NET_ENABLE=1
# export NCCL_OOB_NET_IFNAME="mlx5"
export NCCL_SOCKET_IFNAME=ib
export NCCL_IB_HCA="mlx5"
export NCCL_ASYNC_ERROR_HANDLING=1
export TORCH_CUDA_ALLOC_CONF=garbage_collection_threshold:0.6,max_split_size_mb:512
export NCCL_IB_SL=1
export NCCL_IB_CUDA_SUPPORT=1
export NCCL_IB_GDR_LEVEL=SYS
export NCCL_P2P_LEVEL=NVL
export NCCL_CUMEM_ENABLE=1

function start_ray_head() {
  echo "[head] starting Singularity instance ($HEAD_NODE)..."
  echo "VLLM_HOST_IP=$VLLM_HOST_IP" > {{ cfg.log_directory }}/{{ job_name }}/${REPL_ID}.env
  
  singularity instance start --bind $MOUNTS --writable-tmpfs \
                --env-file {{ cfg.log_directory }}/{{ job_name }}/${REPL_ID}.env \
                --nv --contain "$VLLM_IMAGE" "$INSTANCE_TAG" \
                --disable-usage-stats --head --block \
                --port=$HEAD_PORT --dashboard-host=0.0.0.0 --dashboard-port=8265
}

function wait_for_ray_ready() {
  echo "[head] waiting for Ray to come up ..."
  until singularity exec instance://"$INSTANCE_TAG" ray status &>/dev/null; do
    singularity exec instance://"$INSTANCE_TAG" env | grep VLLM_HOST_IP
    sleep 2
  done
  echo "[head] Ray OK"
}

function start_ray_workers() {
  local comma_separated_workers=$(IFS=,; echo "${NODES[*]:1}")
  echo "[workers] launching Ray workers on $((SLURM_JOB_NUM_NODES-1)) nodes ($comma_separated_workers)..."
  
  srun --ntasks=$((SLURM_JOB_NUM_NODES-1)) \
     --nodelist=$comma_separated_workers \
     --nodes=$((SLURM_JOB_NUM_NODES-1)) \
     --ntasks-per-node=1 \
     --exclusive \
     --error="$LOG_DIR/worker_%t.err" \
     --output="$LOG_DIR/worker_%t.out" \
     bash -c '
       export SINGULARITYENV_VLLM_HOST_IP=$(hostname -I | awk "{print \$1}")
       echo "VLLM_HOST_IP is $SINGULARITYENV_VLLM_HOST_IP"
       singularity exec --bind '"$MOUNTS"' --nv --contain \
         '"$VLLM_IMAGE"' \
         ray start --disable-usage-stats \
               --address='"$HEAD_NODE"':'"$HEAD_PORT"' \
               --block
     ' &
  
  echo "[workers] waiting for workers to start ..."
  sleep 60
}

function start_vllm_server() {
  echo "[head] starting vLLM REST server ..."
  singularity exec --bind $MOUNTS --contain --nv --env VLLM_USE_PRECOMPILED=1 \
           instance://"$INSTANCE_TAG" \
           vllm serve {{ cfg.model }} \
           {% if 'tensor-parallel-size' not in cfg.vllm_args %}
           --tensor-parallel-size {{ [cfg.gpus_per_replica,cfg.gpus_per_node] | min }} \
           {% endif %}
           --distributed-executor-backend ray \
           {{ cfg.vllm_args | default('') }} \
           --port $REST_PORT \
           >> "$LOG_DIR/vllm_head.log" 2>&1 &
}

function wait_for_vllm_server_ready() {
  echo "[head] checking vLLM status ..."
  while :; do
    resp=$(curl -sf -w '\n%{http_code}' "http://$HEAD_NODE:$REST_PORT/v1/models" || true)
    body=${resp%$'\n'*}
    code=${resp##*$'\n'}
    
    if [[ $code == 200 ]]; then
      echo "[head] vLLM is READY (HTTP 200)"
      break
    fi
    
    echo "[head] waiting for vLLM (code=$code)â€¦"
    sleep 5
  done
  
  echo "[head] REST ready â†’ http://$HEAD_NODE:$REST_PORT"
  local head_file="{{ cfg.home_directory }}/swarms/${SLURM_ARRAY_JOB_ID}/${REPL_ID}.head"
  echo "$HEAD_NODE:$REST_PORT" > "$head_file"
}

# Execute multi-node deployment steps
start_ray_head
wait_for_ray_ready
start_ray_workers
echo "[head] checking Ray status ..."
singularity exec instance://"$INSTANCE_TAG" ray status
start_vllm_server
wait_for_vllm_server_ready

# Keep job alive
trap 'echo "[batch] caught SIGTERM â†’ shutting down"; exit 0' SIGTERM

while true; do
  sleep 60
done

singularity instance stop "$INSTANCE_TAG" || true
{% endif %}