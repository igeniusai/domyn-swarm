#!/bin/bash
#SBATCH --account=iGen_train
#SBATCH --mail-user=federico.dambrosio@igenius.ai
#SBATCH --qos=qos_llm_min

#SBATCH --exclusive
#SBATCH --job-name={{ job_name }}-lb
#SBATCH --partition={{ cfg.partition }}
#SBATCH --nodes=1
#SBATCH --cpus-per-task={{ cfg.driver.cpus_per_task }}
#SBATCH --mem={{ cfg.driver.mem }}
#SBATCH --threads-per-core={{ cfg.driver.threads_per_core }}
#SBATCH --time={{ cfg.driver.wall_time }}
#SBATCH --output={{ cfg.log_directory }}/lb_%j.out
#SBATCH --error={{ cfg.log_directory }}/lb_%j.err

set -eu
REPLICAS={{ cfg.replicas }}
HOME_DIR="{{ cfg.home_directory }}"
HOST_DIR="${HOME_DIR}/swarms"
WAIT_SEC={{ cfg.lb_wait | default(600) }}
NGINX_IMG={{ cfg.nginx_image }}
INSTANCE_NAME="lb_${DEP_JOBID}_${SLURM_JOB_ID}"
PORT={{ cfg.lb_port }}


###############################################################################
#  Everything from here uses Bash ${} that would confuse Jinja:
#  wrap it in a raw block so Jinja leaves it alone.
###############################################################################
{% raw %}

echo "[lb] waiting for $REPLICAS head files from job $DEP_JOBID"

t0=$(date +%s)
files=()
while true; do
    files=( $(ls "$HOST_DIR/${DEP_JOBID}/"*".head" 2>/dev/null || true) )
    if (( ${#files[@]} == REPLICAS )); then
        break
    fi
    if (( $(date +%s) - t0 > WAIT_SEC )); then
        echo "[lb] timeout: only ${#files[@]}/$REPLICAS replicas became healthy" >&2
        exit 1
    fi
    sleep 5
done

echo "[lb] all replicas ready → ${files[*]}"

upstreams=""
for f in "${files[@]}"; do
    addr=$(cat "$f")
    upstreams+="    server $addr;\n"
done

{% endraw %}

mkdir -p "{{ cfg.log_directory }}/$DEP_JOBID/"

{
    echo "pid /tmp/nginx.pid;"
    echo "events { worker_connections 100000; }"
    echo "http {"
    echo "  upstream llm {"
    echo "    least_conn;"
    for f in "${files[@]}"; do
        addr=$(<"$f")                    # faster cat
        echo "    server $addr max_fails=2 fail_timeout=10s;"
    done
    echo "  }"
    cat <<CONF
  server {
    listen $PORT;
    location / {
      proxy_pass http://llm;
      proxy_connect_timeout       3600;
      proxy_send_timeout          3600;
      proxy_read_timeout          3600;
      send_timeout                3600;
      proxy_set_header Connection "";
      sendfile on;
      tcp_nopush on;
      tcp_nodelay on;
      keepalive_timeout 65;
      {% if cfg.driver.enable_proxy_buffering %}
      # ───── Proxy Response Buffering ─────
      proxy_buffer_size 64k;               
      proxy_buffers 16 512k;               
      proxy_busy_buffers_size 1m;          
      proxy_max_temp_file_size 0;
      # ───── Client Request Buffering ─────
      client_max_body_size 50m;         
      client_body_buffer_size 1m;       
      {% else %}
      proxy_buffering off;
      proxy_request_buffering off;
      {% endif %}

      proxy_next_upstream error timeout http_502 http_504;
      proxy_next_upstream_tries 3;
    }
    location = /health {
      proxy_pass http://llm/health;
      proxy_connect_timeout 2s;
      proxy_read_timeout 2s;
      proxy_cache_bypass \$http_upgrade;
    }
  }
}
CONF
} > $HOST_DIR/${DEP_JOBID}/nginx.conf

CACHE_DIR="$TMPDIR/cache"
mkdir -p "$CACHE_DIR"

singularity instance start --writable-tmpfs \
    -B "$HOST_DIR/${DEP_JOBID}/nginx.conf":/etc/nginx/nginx.conf:ro \
    -B "$CACHE_DIR":/var/cache/nginx \
    -B {{ cfg.log_directory }}/$DEP_JOBID:/var/log/nginx \
    "$NGINX_IMG" "$INSTANCE_NAME"

trap 'echo "[batch] caught SIGTERM → shutting down"; exit 0' SIGTERM

while true; do
    sleep 60
done